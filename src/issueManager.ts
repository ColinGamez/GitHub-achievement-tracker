/**
 * issueManager.ts — Create and manage GitHub issues.
 *
 * Issues are the starting point of every orchestrated workflow:
 *   1. An issue is opened with a meaningful title/body + labels.
 *   2. A branch and PR are later created referencing the issue.
 *   3. The issue is closed automatically when the PR merges (via "Closes #N").
 *
 * This module is intentionally stateless — it communicates results
 * back to the caller via return values so the orchestrator can feed
 * them into the next stage of the pipeline.
 */

import {
  octokit,
  owner,
  repo,
  withRateLimit,
} from "./githubClient";
import {
  log,
  getRandomIssueTitle,
  getRandomIssueBody,
  nowISO,
} from "./utils";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/** The information downstream modules need about a newly created issue. */
export interface CreatedIssue {
  /** Issue number (e.g. 42). */
  number: number;
  /** Full title string. */
  title: string;
  /** ISO-8601 creation timestamp. */
  createdAt: string;
  /** The HTML URL for human consumption. */
  htmlUrl: string;
}

// ---------------------------------------------------------------------------
// Label bootstrapping
// ---------------------------------------------------------------------------

/** Labels the orchestrator applies to issues it creates. */
const ORCHESTRATOR_LABELS: readonly { name: string; color: string; description: string }[] = [
  {
    name: "orchestrator",
    color: "6f42c1",
    description: "Created by GitHub Activity Orchestrator",
  },
  {
    name: "enhancement",
    color: "a2eeef",
    description: "New feature or request",
  },
  {
    name: "automated",
    color: "0e8a16",
    description: "Generated by automation tooling",
  },
];

/**
 * Ensure the labels we need exist in the repo.
 * Idempotent — safe to call on every run.
 */
export async function ensureLabels(): Promise<void> {
  for (const label of ORCHESTRATOR_LABELS) {
    try {
      await octokit.issues.getLabel({ owner, repo, name: label.name });
      log.debug(`Label "${label.name}" already exists.`);
    } catch {
      // Label does not exist → create it.
      await withRateLimit(`create-label-${label.name}`, () =>
        octokit.issues.createLabel({
          owner,
          repo,
          name: label.name,
          color: label.color,
          description: label.description,
        })
      );
      log.info(`Created label: ${label.name}`);
    }
  }
}

// ---------------------------------------------------------------------------
// Issue creation
// ---------------------------------------------------------------------------

/**
 * Open a new issue with a randomly selected (but meaningful) title and body.
 *
 * Returns metadata that downstream modules use to create the matching
 * branch, commits, and pull request.
 */
export async function createIssue(): Promise<CreatedIssue> {
  // Ensure labels are available before we reference them.
  await ensureLabels();

  const title = getRandomIssueTitle();
  const body = getRandomIssueBody();
  const labels = ORCHESTRATOR_LABELS.map((l) => l.name);

  const { data } = await withRateLimit("create-issue", () =>
    octokit.issues.create({
      owner,
      repo,
      title,
      body,
      labels,
    })
  );

  const created: CreatedIssue = {
    number: data.number,
    title: data.title,
    createdAt: data.created_at ?? nowISO(),
    htmlUrl: data.html_url,
  };

  log.info(`Opened issue #${created.number}: ${created.title}`);
  return created;
}

// ---------------------------------------------------------------------------
// Issue closing (explicit — also happens via PR merge + "Closes #N")
// ---------------------------------------------------------------------------

/**
 * Close an issue by number.
 * Primarily used as a fallback if the PR merge did not auto-close it.
 */
export async function closeIssue(issueNumber: number): Promise<void> {
  await withRateLimit("close-issue", () =>
    octokit.issues.update({
      owner,
      repo,
      issue_number: issueNumber,
      state: "closed",
    })
  );
  log.info(`Closed issue #${issueNumber}`);
}
